const { ethers } = require("ethers");
const axios = require("axios");

const rpcUrl = "https://endpoints.omniatech.io/v1/arbitrum/one/public";
const privateKey = "your_private_key_here";
const provider = new ethers.providers.JsonRpcProvider(rpcUrl);
const wallet = new ethers.Wallet(privateKey, provider);

const targets = [
  "0xDE30D6edD20c573746758E817782e43E747d56CC",
  "0xDE30D6edD20c573746758E817782e43E747d56CC",
  "0xDE30D6edD20c573746758E817782e43E747d56CC"
];

const dataPayloads = [
  "0x93fe11ff000000000000000000000000d8f09a9b6bac0b86278aac437c647255c2815afb7355534400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f68e8131ecf800004c617965725a65726f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000027b10000000000000000000000000000000000000000000000000000000000000000",
  "0x93fe11ff000000000000000000000000d8f09a9b6bac0b86278aac437c647255c2815afb7355534400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f68e8131ecf800004c617965725a65726f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000027b10000000000000000000000000000000000000000000000000000000000000000",
  "0x93fe11ff000000000000000000000000d8f09a9b6bac0b86278aac437c647255c2815afb7355534400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005f68e8131ecf800004c617965725a65726f000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000027b10000000000000000000000000000000000000000000000000000000000000000"
];

const sendTransaction = async (to, data) => {
  try {
    const tx = await wallet.sendTransaction({
      to,
      data,
      gasLimit: ethers.utils.hexlify(500000)
    });
    console.log(`Tx Hash: ${tx.hash}`);
    const receipt = await tx.wait();
    console.log(`Transaction mined: ${receipt.transactionHash}`);
  } catch (error) {
    console.error(`Error sending transaction: ${error}`);
  }
};

const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

const randomDelay = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);

const main = async () => {
  for (let i = 0; i < targets.length; i++) {
    console.log(`Sending transaction ${i + 1} of ${targets.length}`);
    await sendTransaction(targets[i], dataPayloads[i]);
    const delayTime = randomDelay(30000, 120000);
    console.log(`Waiting for ${delayTime / 1000} seconds before next transaction...`);
    await delay(delayTime);
  }
};

main().catch(console.error);
